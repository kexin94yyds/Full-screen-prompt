# 搜索优化逻辑说明

> 标题匹配优先的智能搜索排序实现

---

## 📋 功能概述

实现了基于匹配质量的智能搜索排序，确保标题匹配的结果优先显示。

### 优先级规则

1. **标题完全匹配** - 分数 1000 ⭐⭐⭐⭐⭐
2. **标题开头匹配** - 分数 500 ⭐⭐⭐⭐
3. **标题包含匹配** - 分数 100 ⭐⭐⭐
4. **内容匹配** - 分数 10 ⭐⭐

---

## 🔧 核心实现

### 1. 模式内搜索 - `displayPrompts` 函数

**位置：** `app.js` 第 269-310 行

```javascript
// 显示提示词列表
function displayPrompts(prompts, searchTerm = '') {
  promptsList.innerHTML = '';
  
  let filteredPrompts;
  if (searchTerm) {
    const lowerSearchTerm = searchTerm.toLowerCase();
    
    // 过滤并计算匹配分数
    filteredPrompts = prompts
      .filter(p => 
        p.name.toLowerCase().includes(lowerSearchTerm) || 
        p.content.toLowerCase().includes(lowerSearchTerm)
      )
      .map(p => {
        const lowerName = p.name.toLowerCase();
        const lowerContent = p.content.toLowerCase();
        let score = 0;
        
        // 标题完全匹配 - 最高优先级
        if (lowerName === lowerSearchTerm) {
          score = 1000;
        }
        // 标题开头匹配 - 高优先级
        else if (lowerName.startsWith(lowerSearchTerm)) {
          score = 500;
        }
        // 标题包含匹配 - 中高优先级
        else if (lowerName.includes(lowerSearchTerm)) {
          score = 100;
        }
        // 内容匹配 - 普通优先级
        else if (lowerContent.includes(lowerSearchTerm)) {
          score = 10;
        }
        
        return { ...p, score };
      })
      // 按分数降序排序（分数高的在前）
      .sort((a, b) => b.score - a.score);
  } else {
    filteredPrompts = prompts;
  }
  
  // 后续渲染逻辑...
  filteredPrompts.forEach(function(prompt, index) {
    // 创建 DOM 元素...
  });
}
```

**用途：** 在当前模式内搜索提示词时使用

---

### 2. 全局搜索 - `displayGlobalSearchResults` 函数

**位置：** `app.js` 第 1101-1142 行

```javascript
function displayGlobalSearchResults(prompts, searchTerm) {
  promptsList.innerHTML = '';
  
  const lowerSearchTerm = searchTerm.toLowerCase();
  console.log('🔍 搜索词:', searchTerm);
  
  // 过滤并计算匹配分数，然后排序
  const searchResults = prompts
    .filter(p => 
      p.name.toLowerCase().includes(lowerSearchTerm) || 
      p.content.toLowerCase().includes(lowerSearchTerm)
    )
    .map(p => {
      const lowerName = p.name.toLowerCase();
      const lowerContent = p.content.toLowerCase();
      let score = 0;
      
      // 标题完全匹配 - 最高优先级
      if (lowerName === lowerSearchTerm) {
        score = 1000;
      }
      // 标题开头匹配 - 高优先级
      else if (lowerName.startsWith(lowerSearchTerm)) {
        score = 500;
      }
      // 标题包含匹配 - 中高优先级
      else if (lowerName.includes(lowerSearchTerm)) {
        score = 100;
      }
      // 内容匹配 - 普通优先级
      else if (lowerContent.includes(lowerSearchTerm)) {
        score = 10;
      }
      
      console.log(`  "${p.name}" - 分数: ${score}`);
      return { ...p, score };
    })
    // 按分数降序排序（分数高的在前）
    .sort((a, b) => b.score - a.score);
  
  console.log('📊 排序后的结果:');
  searchResults.forEach((p, i) => console.log(`  ${i+1}. "${p.name}" (分数: ${p.score})`));
  
  // 后续渲染逻辑...
}
```

**用途：** 跨所有模式全局搜索时使用（带调试日志）

---

## 📊 算法流程

```
输入搜索词 "更新"
    ↓
转换为小写 "更新"
    ↓
过滤匹配的提示词
    ├─ 标题包含 "更新"
    └─ 内容包含 "更新"
    ↓
为每个匹配项计算分数
    ├─ "更新" → 1000 (完全匹配)
    ├─ "更新日志" → 500 (开头匹配)
    ├─ "代码更新规范" → 100 (包含匹配)
    └─ "如何使用" (内容含"更新") → 10 (内容匹配)
    ↓
按分数降序排序
    ↓
显示排序后的结果
```

---

## 💡 使用示例

### 示例 1：搜索 "更新"

**假设有以下提示词：**
1. 标题："更新"，内容："版本更新说明"
2. 标题："更新日志"，内容："记录所有更新"
3. 标题："代码更新规范"，内容："提交代码时的规范"
4. 标题："开发指南"，内容："包含更新流程"
5. 标题："问题"，内容："更新后的常见问题"

**排序结果：**
```
1. 更新 (分数: 1000) ← 完全匹配
2. 更新日志 (分数: 500) ← 开头匹配
3. 代码更新规范 (分数: 100) ← 包含匹配
4. 开发指南 (分数: 10) ← 内容匹配
5. 问题 (分数: 10) ← 内容匹配
```

### 示例 2：搜索 "日志"

**排序结果：**
```
1. 日志 (分数: 1000) ← 如果有完全匹配的标题
2. 日志管理 (分数: 500) ← 开头匹配
3. 更新日志 (分数: 100) ← 包含匹配
4. 调试方法 (分数: 10) ← 内容中提到日志
```

---

## 🔍 调试方法

### 1. 开启控制台查看日志

在应用中按 `Cmd + Option + I` 打开开发者工具，然后搜索：

**控制台输出示例：**
```
🔍 搜索词: 更新
  "更新" - 分数: 1000
  "更新日志" - 分数: 500
  "代码更新规范" - 分数: 100
  "开发指南" - 分数: 10
📊 排序后的结果:
  1. "更新" (分数: 1000)
  2. "更新日志" (分数: 500)
  3. "代码更新规范" (分数: 100)
  4. "开发指南" (分数: 10)
```

### 2. 移除调试日志（生产环境）

如需移除调试日志，删除以下代码行：

```javascript
// 移除这些行
console.log('🔍 搜索词:', searchTerm);
console.log(`  "${p.name}" - 分数: ${score}`);
console.log('📊 排序后的结果:');
searchResults.forEach((p, i) => console.log(`  ${i+1}. "${p.name}" (分数: ${p.score})`));
```

---

## 📝 同步更新位置

搜索逻辑在以下文件中需要保持一致：

### Mac 应用版本
- ✅ `app.js` - 第 269-310 行（模式内搜索）
- ✅ `app.js` - 第 1101-1142 行（全局搜索）

### Chrome 插件版本
- ✅ `popup.js` - 第 258-299 行（模式内搜索）
- ✅ `popup.js` - 第 1086-1122 行（全局搜索）

---

## 🎯 性能考虑

### 时间复杂度
- **过滤：** O(n) - 遍历所有提示词
- **评分：** O(n) - 为每个匹配项计算分数
- **排序：** O(n log n) - JavaScript 内置排序
- **总计：** O(n log n)

### 优化建议

1. **缓存小写转换**（已实现）
   ```javascript
   const lowerSearchTerm = searchTerm.toLowerCase();
   const lowerName = p.name.toLowerCase();
   ```

2. **使用 `else if` 避免重复检查**（已实现）
   - 标题完全匹配后不再检查其他条件

3. **提前终止**（可选优化）
   ```javascript
   // 如果标题完全匹配，直接返回最高分
   if (lowerName === lowerSearchTerm) {
     return { ...p, score: 1000 };
   }
   ```

4. **限制结果数量**（大数据集优化）
   ```javascript
   // 只显示前 100 个结果
   searchResults.slice(0, 100).forEach(...)
   ```

---

## 🔧 扩展功能

### 1. 模糊匹配

可以添加模糊匹配支持（如拼音、拼写错误）：

```javascript
// 使用第三方库如 fuse.js
const fuse = new Fuse(prompts, {
  keys: ['name', 'content'],
  threshold: 0.3
});
const results = fuse.search(searchTerm);
```

### 2. 关键词高亮

在显示结果时高亮匹配的关键词：

```javascript
function highlightMatch(text, searchTerm) {
  const regex = new RegExp(`(${searchTerm})`, 'gi');
  return text.replace(regex, '<mark>$1</mark>');
}

promptName.innerHTML = highlightMatch(prompt.name, searchTerm);
```

### 3. 搜索历史

记录用户的搜索历史：

```javascript
function addToSearchHistory(searchTerm) {
  let history = store.get('searchHistory') || [];
  history.unshift(searchTerm);
  history = [...new Set(history)].slice(0, 10); // 去重并限制10条
  store.set('searchHistory', history);
}
```

### 4. 权重配置

允许用户自定义匹配权重：

```javascript
const WEIGHTS = {
  exactMatch: 1000,
  startsWith: 500,
  contains: 100,
  content: 10
};

// 在设置中允许用户调整
```

---

## 🐛 已知问题

### 1. 大小写敏感度

**当前行为：** 不区分大小写（已转换为小写）

**可能问题：** 对于需要区分大小写的场景（如代码片段），可能不够精确

**解决方案：** 添加"区分大小写"选项

```javascript
const lowerSearchTerm = caseSensitive 
  ? searchTerm 
  : searchTerm.toLowerCase();
```

### 2. 特殊字符

**当前行为：** 直接匹配特殊字符

**可能问题：** 正则表达式特殊字符可能导致错误

**解决方案：** 转义特殊字符（如使用正则时）

---

## ✅ 测试案例

### 测试 1：完全匹配优先
```
搜索词：更新
期望：标题为"更新"的排第一
✅ 通过
```

### 测试 2：开头匹配次之
```
搜索词：更新
期望：标题为"更新日志"排在"代码更新"前面
✅ 通过
```

### 测试 3：标题优先于内容
```
搜索词：更新
期望：标题包含"更新"的排在只有内容包含的前面
✅ 通过
```

### 测试 4：空搜索
```
搜索词：（空）
期望：显示所有提示词，按原始顺序
✅ 通过
```

### 测试 5：无匹配结果
```
搜索词：xyzabc123
期望：显示"没有找到匹配的提示词"
✅ 通过
```

---

## 📅 更新历史

| 日期 | 版本 | 更新内容 |
|------|------|---------|
| 2025-10-29 | v1.0 | 初始实现标题优先排序 |
| 2025-10-29 | v1.1 | 添加调试日志输出 |

---

## 📞 相关文件

- **实现文件：** `app.js`, `popup.js`
- **问题文档：** `问题排除手册.md` - 第 4 章
- **Git 提交：** `feat: 优化搜索排序逻辑 - 标题匹配优先` (64f085d)

---

**维护者：** Claude  
**最后更新：** 2025-10-29  
**适用版本：** v2.0.0+

